<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="With lutline you generate a look-up table based on a command-line interface specification, and the code needed to access it while looping through argv.">
        <meta name="author" content="Filipe Funenga">
        <link rel="icon shortcut" href="images/favicon.ico">
        <title>lutline - Command-line interface specification
</title>
        <link href="css/bootstrap.min.css" rel="stylesheet">
        <link href="css/jumbotron-narrow.css" rel="stylesheet">
        <style>
            .toc {
                margin-top: 30px;
            }
            @media (min-width: 768px) {
                .toc {
                    margin-top: 0px;
                    float:right;
                    margin-left:30px;
                    width: 300px;
                }
            }
        </style>
    </head>

    <body>
        <div class="container">
            <div class="header fixed-top clearfix">
                <ul class="nav nav-pills">
                    <li role="presentation" style="margin-right:20px;"><a href="index.html"><span class="glyphicon glyphicon-chevron-up" aria-hidden="true"></span> Home</a></li>
                    <li role="presentation"><h3 class="pull-right" role="presentation">Command-line interface specification
</h3></li>
                </ul>
            </div>
            <div class="toc">
                <div class="panel panel-default">
                    <div class="panel-body">
                        <p>Contents:</p>
                        <ul>
  <li><a href="#structure">Structure</a></li>
  <li><a href="#elements">Elements</a></li>
  <li><a href="#relations">Relations</a></li>
  <li><a href="#example-1-docker-commit">Example 1 - docker commit</a></li>
  <li><a href="#future-plans">Future plans</a></li>
</ul>

                    </div>
                </div>
            </div>
            <h2 id="structure">Structure</h2>

<p>The <em>specfile</em> is a simple text file divided in three parts:</p>

<ul>
<li>a Command-Line Interface (CLI) specification</li>
<li>(optional) a usage message</li>
<li>(optional) a description message</li>
</ul>

<p>The CLI specification is the core of the <em>specfile</em> and is where the developer
provides the pattern that is to be implemented by the CLI parser. This part of
the <em>specfile</em> describes a tree where each leaf is an <em>element</em> and each
branch is a <em>relation</em>.</p>

<p>The <em>lutline</em> parser assumes that the <em>specfile</em> first describes the CLI
specification and then, optionally, describes the usage and description
messages, where the first line of that block starts with the sub-string
<code>usage:</code>. This search operation is not sensible to the capitalization
(e.g. <code>Usage</code> and <code>USAGE</code> also match).</p>

<p>If no line in the <em>specfile</em> verifies
<code>line.lower().startswith('usage:')</code>, than the entire file's
contents are identified as the CLI specification. On the contrary, if one
line verifies that condition, than the contents starting from that line are
considered to describe the usage and description messages.</p>

<p>The optional description message starts from the first line without any
indentation after the <code>usage:</code> line.</p>

<h2 id="elements">Elements</h2>

<p>Currently, there are two elements supported by <em>lutline</em>:</p>

<table class="table table-striped">
<thead>
<tr>
  <th><em>specfile</em></th>
  <th>Pattern representation</th>
  <th>Received in <code>argv</code></th>
  <th>Type</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>explicit {label}</code></td>
  <td><code>"%s" % label</code></td>
  <td>label</td>
  <td>Boolean</td>
</tr>
<tr>
  <td><code>implicit {label}</code></td>
  <td><code>"&lt;%s&gt;" % label</code></td>
  <td>value</td>
  <td>String</td>
</tr>
</tbody>
</table>

<p>An explicit element is represented in <code>argv</code> with its label. On the contrary,
an implicit element is not directly recognizable in <code>argv</code>, since
the user places a string value in there, instead of its label.</p>

<h2 id="relations">Relations</h2>

<p>Currently, there are four relations supported by <em>lutline</em>:</p>

<table class="table table-striped">
<thead>
<tr>
  <th><em>specfile</em></th>
  <th>Pattern representation</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>required</code></td>
  <td><code>"( children[0] children[1] (...) children[n] )"</code></td>
</tr>
<tr>
  <td><code>optional</code></td>
  <td><code>"[ children[0] children[1] (...) children[n] ]</code></td>
</tr>
<tr>
  <td><code>exclusive</code></td>
  <td><code>( children[0]</code>&verbar;<code>children[1]</code>&verbar;<code>(...)</code>&verbar;<code>children[n] )</code></td>
</tr>
<tr>
  <td><code>unordered</code></td>
  <td><code>{ children[0] children[1] (...) children[n] }</code></td>
</tr>
</tbody>
</table>

<p>As you can see, these relations are common, except for <code>unordered</code>.</p>

<p><span class="label label-success">Required</span> Defines an ordered set of
branches or elements. This relation has one embodiment: its children in the
same order they appear in the pattern representation. For example, the
following CLI specification:</p>

<pre><code>required:
    explicit -f
    implicit input_file

Usage: app.py (-f &lt;input_file&gt;)
</code></pre>

<p>has the following embodiment:</p>

<ol>
<li><code>app.py -f &lt;input_file&gt;</code></li>
</ol>

<p><span class="label label-success">Optional</span> Equivalent to a <code>required</code>
branch with two possible embodiments: either with the normal <code>required</code>
embodiment, OR by not existing in the parent branch. For example, the
following CLI specification:</p>

<pre><code>optional:
    explicit -f
    implicit input_file

Usage: app.py [-f &lt;input_file&gt;]
</code></pre>

<p>has the following embodiments:</p>

<ol>
<li><code>app.py -f &lt;input_file&gt;</code></li>
<li><code>app.py</code></li>
</ol>

<p><span class="label label-success">Exclusive</span> Defines a set of branches
or elements that is embodied one child at a time. For example, the following
CLI specification:</p>

<pre><code>exclusive:
    explicit -f
    implicit input_file

Usage: app.py (-f | &lt;input_file&gt;)
</code></pre>

<p>has the following embodiments:</p>

<ol>
<li><code>app.py -f</code></li>
<li><code>app.py &lt;input_file&gt;</code></li>
</ol>

<p><span class="label label-success">Unordered</span> Defines a set of branches
or elements that is embodied by each permutation of the children. For
example, the following CLI specification:</p>

<pre><code>unordered:
    explicit -f
    implicit input_file

Usage: app.py {-f | &lt;input_file&gt;}
</code></pre>

<p>has the following embodiments:</p>

<ol>
<li><code>app.py -f &lt;input_file&gt;</code></li>
<li><code>app.py &lt;input_file&gt; -f</code></li>
</ol>

<h2 id="example-1-docker-commit">Example 1 - docker commit</h2>

<p>In this first example, a simplified version of the <code>docker commit</code> command
will be transcribed to a <em>lutline</em>'s <em>specfile</em>.</p>

<pre><code>required:
    explicit commit
    unordered:
        optional:
            required:
                exclusive:
                    explicit -a
                    explicit --author
                implicit author
        optional:
            required:
                exclusive:
                    explicit -c
                    explicit --change
                implicit changes
        optional:
            explicit --help
        optional:
            required:
                exclusive:
                    explicit -m
                    explicit --message
                implicit message
        optional:
            exclusive:
                explicit -p
                explicit --pause
    implicit container
    optional:
        implicit repository_tag

Usage:  docker commit [OPTIONS] &lt;container&gt; [&lt;repository&gt;]

Create a new image from a container's changes
  (-a | --author) &lt;author&gt;    Author (e.g., "John Hannibal Smith &lt;hannibal@a-team.com&gt;")
  (-c | --change) &lt;changes&gt;   Apply Dockerfile instruction to the created image
  --help                      Print usage
  (-m | --message) &lt;message&gt;  Commit message
  (-p | --pause)              Pause container during commit
</code></pre>

<p>The <code>Usage:</code> marker shows a simplified pattern using the <code>[OPTIONS]</code>
representation. This pattern code entails that any of the options can be
optionally placed at that location in any order. This type of relation
greatly increases the number of embodiments.</p>

<h2 id="future-plans">Future plans</h2>

<p><span class="label label-primary">TODO</span>
In the future, the plans are to support a third element where explicit and
implicit elements are <em>mixed</em> in the same index of <code>argv</code>. For example,
the pattern <code>--time=&lt;time&gt;</code> can be defined in the <em>specfile</em> as:</p>

<pre><code>element:
    explicit --time=
    implicit time
</code></pre>

<p>For example, the pattern <code>(-t | --time)=&lt;clock&gt;</code> can be defined in the
<em>specfile</em> as:</p>

<pre><code>element:
    exclusive:
        explicit -t=
        explicit --time=
    implicit clock
</code></pre>

<p><span class="label label-primary">TODO</span>
Also, in the future the plans are to support aliases. For example when the
following element appears on the <em>specfile</em>:</p>

<pre><code>flag time
</code></pre>

<p>it is converted to:</p>

<pre><code>exclusive:
    explicit -t
    explicit --time
</code></pre>

<p>Or, for example, when the following element appears on the <em>specfile</em>:</p>

<pre><code>option time
</code></pre>

<p>it is converted to:</p>

<pre><code>exclusive:
    element:
        exclusive:
            explicit -t=
            explicit --time=
        implicit time
    required:
        flag time
        implicit time
</code></pre>

<p><span class="label label-primary">TODO</span>
Further, in the future the plans are to support the <code>atleastone</code> ("at least
one") relation. In order to accomplish this objective it will be important
find a way of changing the look-up table (LUT) parser code that will allow to
perform this functionality. A possibility is to create a different LUT for
each <code>atleastone</code> branch.</p>

            <footer class="footer">
                <div style="float:left;"><a href="https://github.com/ffunenga/lutline/blob/master/LICENSE">Check the MIT License</a></div>
                <div style="float:right;">This page was generated in 2015-11-24 20:16:00</div>
            </footer>
        </div>

        <script src="js/jquery.min.js"></script>
        <script src="js/bootstrap.min.js"></script>
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
            ga('create', 'UA-35879263-5', 'auto');
            ga('send', 'pageview', 'specfile.html');
        </script>
    </body>
</html>
