# Tutorial - A basic CLI for a command-line application

The following tutorial is based on the following assumptions:
  - a python developer wants to implement a command-line interface (CLI) for an
    application he is developing `./app [-f] <fin>`;
  - the developer has a file in his project called `spec.py` with a
    specification of the CLI he wants to implement;
  - the developer wants to generate a module called `cli.py` based on `spec.py`,
    allowing him to do something like `import cli; args = cli.parse()` in an
    initial function of his application.

In the above-mentioned scenario, the developer could easily implement his
application in another programming language, for example C or Ruby.

The following description, describes how *lutline* can be used to generate the
`cli.py` file.

```
$ virtualenv venv
New python executable in venv/bin/python
Installing setuptools, pip, wheel...done.
$ source venv/bin/activate
(venv)$ pip install lutline
(...)
Installing collected packages: lutline
Successfully installed lutline-0.0.1
(venv)$ ls
main.py  spec.py
(venv)$ lutline -l py -f spec.py -o cli.py
(venv)$ ls
cli.py  main.py  spec.py
(venv)$ deactivate
$ rm -r venv
```

## Installation

First, the developer needs to make *lutline* available in a Python
environment, for example in a *virtualenv*.

```
$ virtualenv venv
$ source venv/bin/activate
(venv)$ pip install lutline
(venv)$ ls
main.py  spec.py
```

*Lutline* is also installed as a command-line tool. The developer
will be using this tool to generate the `cli.py` file.

## Generating a parser

The `spec.py` file has the following content.

```
(venv)$ cat spec.py
usage = "usage: ./app [-f] <fin>"
spec = [
    ['opt', [['f', 'f'],
             ['a', 'fout']]
    ],
    ['a', 'fin']
]
```

The structural description provided by the `spec` variable, is quite basic to
understand:
  - each node of the pattern is represented by a tuple (type, content);
  - type can be an element, such as 'a', 'f' or 'c' (argument, flag or command,
    respectively), or a relation, such as 'req', 'opt', 'exc' or 'uns'
    (required, optional, exclusive or unsorted, respectively).
  - when the type is an element, the content is its label;
  - when the type is a relation, the content is a list of child nodes.

Now the developer runs *lutline* as follows:

```
(venv)$ lutline
usage: lutline [-l <language>] -f <spec_file> [-o <output_file>]
(...)
(venv)$ lutline -l py -f spec.py -o cli.py
```

## Using the parser

The developer lists the source files and he finds the following.

```
(venv)$ ls
cli.py  main.py  spec.py
```

The `cli.py` file comprises a look-up table (LUT), specifically tailored to the
CLI specification provided by the `spec.py` file, and a function to match the
`argv` array against the LUT. In the initial function of his application, the
developer imports `cli.py` and runs the function `parse()`.

```
#!/usr/bin/env python

import cli

def main():
    args = cli.parse()
    (...)

if __name__ == "__main__":
    main()
```

`cli.parse()` only returns when the CLI pattern is satisfied, otherwise it
internally aborts execution with python's `sys.exit(...)`.

## (optional) Detaching lutline from the project dependencies

The file generated by *lutline*, `cli.py`, only requires the `sys` module
provided by Python itself (in order to grab the `argv` array). This means that
from the moment said file is generated, *lutline* is no longer required in the
developers system. Basically, *lutline* is a development-time dependency, as
opposed to a compilation or run time dependency.

Since in the provided scenario, the developer was using a virtual environment,
detaching *lutline* is simply achieved with the following.

```
(venv)$ deactivate
$ rm -r venv
```
