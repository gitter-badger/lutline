Tutorial - Getting started
## Setting up

Install *lutline* in your Python environment using [pip](http://pip.readthedocs.org/).

    $ pip install lutline

## Generating a parser

Start by creating a simple `specfile.txt`, where you describe your
Command-Line Interface (CLI) specification, a usage message and a
description of your CLI.

    $ cat specfile.txt
    required:
        optional:
            explicit -f
            implicit fout
        implicit fin

    Usage: app.py [-f <fout>] <fin>

    This application processes the information in <fin> and outputs the results
    to a new file called <fout>. If <fout> is not provided, the default value
    will be 'output.txt'

    Arguments:
        <fin>       The input filename

    Options:
        -f <fout>   The output filename. Default value is 'output.txt'

You can find out more details about the above format in [this
page](specfile.html). Basically, once *lutline* finds the first occurrence of
`usage:` it simply copy/paste's the text following that marker, to the right
locations in a template. The CLI specification that precedes that marker
describes the pattern that you want to parse. As you can see, it is easy to
draft and very versatile.

In this tutorial, a Python module will be generated based on that
`specfile.txt`. The default output filename is `cli.py`, which is fine for
most scenarios. The module can be generated using the *lutline* command-line
tool as follows (see its USAGE message for more information):

    $ ls
    specfile.txt
    $ lutline specfile.txt
    $ ls
    cli.py  specfile.txt

And now you have a CLI parser with a customized look-up table (LUT) that you
can use in your application.

## Using the parser

You can now test the generated parser either directly or through your
application. For example, this is what it looks like to use the parser directly
for testing purposes.

    $ python cli.py hello.txt
    {'fin': 'hello.txt'}
    $ python cli.py -f bye.txt hello.txt
    {'-f': '-f', 'fout': 'bye.txt', 'fin': 'hello.txt'}
    $ python cli.py --this-option-is-unknown
    Usage: app.py [-f <fout>] <fin>

And this is what it looks like to use the parser from your application:

    $ cat main.py
    import cli

    def main():
      args = cli.parse()
      fout = args.get("fout", "output.txt")
      # (...)

    if __name__ == "__main__":
      main()

The important thing to know about how to use the generated parser in `cli.py`
is that somewhere inside there is a function called `parse()` that returns
a dictionary-like structure with the values provided through `argv`.

## Detaching

The file generated by *lutline*, `cli.py`, only requires the `sys` module
provided by Python itself (in order to grab the `argv` array). This means that
from the moment said file is generated, *lutline* is no longer required in the
developers system. Basically, *lutline* is a development-time dependency, as
opposed to a compilation or run-time dependency.

If a virtual environment is used, detaching *lutline* is easy to achieve.

    $ virtualenv env
    $ source env/bin/activate
    (env)$ pip install lutline
    (env)$ lutline spec.py
    (env)$ deactivate
    $ rm -r env
    # "python main.py" or "python cli.py" still works fine ;)

<br>

If you want to found out more about the inner-problems solved by *lutline*,
than following this link:

* [Parsing a command-line](problem.html)

<br>
