
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="./images/favicon.ico">
    <title>lutline - Python package</title>
    <link href="./css/bootstrap.min.css" rel="stylesheet">
    <link href="./css/jumbotron-narrow.css" rel="stylesheet">
    <script src="./js/ie-emulation-modes-warning.js"></script>
  </head>

  <body>
    <div class="container">
    <div class="header clearfix">
      <nav>
        <a class="btn btn-lg btn-success" role="button" href="https://github.com/ffunenga/lutline"><span class="glyphicon glyphicon-console" aria-hidden="true"></span> View on GitHub</a>
        <ul class="nav nav-pills pull-right">
          <li role="presentation"><a href="https://github.com/ffunenga/lutline/zipball/master" class="btn"><span class="glyphicon glyphicon-download-alt" aria-hidden="true"></span> Download as .zip</a></li>
          <li role="presentation"><a href="https://github.com/ffunenga/lutline/tarball/master" class="btn"><span class="glyphicon glyphicon-download-alt" aria-hidden="true"></span> Download as .tar.gz</a></li>
        </ul>
      </nav>
    </div>

    <div class="jumbotron">
      <h1>lutline</h1>
      <p class="lead">Parse <code>argv</code> using a look-up table generated
        from your command-line interface specification.</p>
    </div>

    <ul>
      <li><a href="#installation">Installation</a></li>
      <li><a href="#using">Using the parser</a></li>
      <li><a href="#generating">Generating a parser</a></li>
      <li><a href="#detaching">(optional) Detaching lutline from the project dependencies</a></li>
    </ul>

    <!--------------------------->
    <h2 id="installation">Installation</h2>
<pre>
  <font color="#b5e853">$</font> pip install lutline
</pre>

    <!--------------------------->
    <h2 id="generating">Generating a parser</h2>
    <p>The basic structure of a command-line interface application, comprises
       an initial parsing stage where arguments received from the
       command-line are matched against a pattern. For example:</p>
<pre>
  <font color="#b5e853">$</font> cat main.py
  #!/usr/bin/env python

  import cli

  def main():
      args = cli.parse()
      # (...)

  if __name__ == "__main__":
      main()
</pre>
    <p>The initial <code>main()</code> function of this application runs the function
      <code>parse()</code> from <code>cli.py</code> module.
      <code>cli.parse()</code> should only return when the CLI pattern is
      satisfied, otherwise it internally aborts execution with an error message.</p>
    <p>So, our objective is to grab a description of the CLI pattern the
      developer wants to implement, and provide him/her with the
      <code>cli.py</code> module. The developer starts by creating the following <code>spec.py</code>
      file.</p>
<pre>
  <font color="#b5e853">$</font> cat spec.py
  usage = "usage: ./superapp [-f &ltfout&gt] &ltfin&gt"
  spec = [
      ['opt', [['f', 'f'],
               ['a', 'fout']]
      ],
      ['a', 'fin']
  ]
</pre>
    <p>The structural description provided by the <code>spec</code> variable, is quite basic to
       understand:</p>
    <ul>
      <li>each node of the pattern is represented by a tuple <code>(type, content)</code>;</li>
      <li>type can be an element, such as 'a', 'f' or 'c' (argument, flag or command,
        respectively), or a relation, such as 'req', 'opt', 'exc' or 'uns'
        (required, optional, exclusive or unsorted, respectively);</li>
      <li>when the type is an element, the content is its label;</li>
      <li>when the type is a relation, the content is a list of child nodes.</li>
    </ul>

    <!--------------------------->
    <h2 id="using">Using the parser</h2>
    <p>The <code>cli.py</code> module can be generated using the <i>lutline</i>
      command-line tool as follows (see its USAGE message for more information).</p>
<pre>
  <font color="#b5e853">$</font> ls
  main.py  spec.py
  <font color="#b5e853">$</font> lutline spec.py
  <font color="#b5e853">$</font> ls
  cli.py  main.py  spec.py
</pre>
    <p>The <code>cli.py</code> file comprises a look-up table (LUT), specifically tailored to the
    CLI specification provided by the <code>spec.py</code> file, and a function to match the
    <code>argv</code> array against the LUT. The cli implemented can now be
    tested directly or through the main application.</p>
<pre>
  <font color="#b5e853">$</font> python cli.py hello.txt
  {'fin': 'hello.txt'}
  <font color="#b5e853">$</font> python cli.py -f bye.txt hello.txt
  {'-f': 'f', 'fout': 'bye.txt', 'fin': 'hello.txt'}
  <font color="#b5e853">$</font> python cli.py --this-option-is-unknown
  usage: ./superapp [-f &ltfout&gt] &ltfin&gt
</pre>

    <!--------------------------->
    <h2 id="detaching">Detaching lutline from the project dependencies</h2>
    <p>The file generated by <i>lutline</i>, <code>cli.py</code>, only requires the <code>sys</code> module
    provided by Python itself (in order to grab the <code>argv</code> array). This means that
    from the moment said file is generated, <i>lutline</i> is no longer required in the
    developers system. Basically, <i>lutline</i> is a development-time dependency, as
    opposed to a compilation or run time dependency.</p>
    <p>If a virtual environmet is used, detaching <i>lutline</i> is simply achieved with the following.</p>
<pre>
  <font color="#b5e853">$</font> virtualenv venv
  <font color="#b5e853">$</font> source venv/bin/activate
  <font color="#b5e853">(venv)$</font> pip install lutline
  <font color="#b5e853">(venv)$</font> lutline spec.py
  <font color="#b5e853">(venv)$</font> deactivate
  <font color="#b5e853">$</font> rm -r venv
  # "python main.py" or "python cli.py" still works fine ;)
</pre>
</div>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="js/bootstrap.min.js"></script>
</body>
</html>
